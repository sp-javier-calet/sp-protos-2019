using Jitter.LinearMath;
using System;
<<<<<<< HEAD
using SocialPoint.Utils;

namespace SocialPoint.Multiplayer
{
=======
using SocialPoint.Pooling;

namespace SocialPoint.Multiplayer
{
    
>>>>>>> origin/master
    public static class InterpolationSettings
    {
        public static bool Enable = true;
        public static double RotationLerpSpeed = 13.0;
    }

    public class ConstantSpeedNetworkInterpolate : INetworkBehaviour, INetworkInterpolate
    {
        public static double PositionLerpSpeed = 18.0;
<<<<<<< HEAD
        const double _epsilon = 1e-4f;
        const double _defMaxDistance = 4f;
=======
        const double _epsilon = 1e-4;
        const double _defMaxDistance = 4;
>>>>>>> origin/master
        const double _minTimeToProcessData = 0.1;
        const int _minIterationCount = 1;

        public bool Enable{ get; set; }

        NetworkGameObject _go;

<<<<<<< HEAD
        JQuaternion _serverRotation;
=======
        JQuaternion _targetRotationPredicted;
>>>>>>> origin/master

        IGameTime _gameTime;

        int _iterationCount;
        bool _canSmooth;
        JVector _dir;
        double _maxDistance;
        double _maxDistanceSQ;

<<<<<<< HEAD
        JVector _serverPos;
=======
        JVector _prevServerPos;
>>>>>>> origin/master

        double _rotationLerpSpeed;

        double _serverTimeStamp;
        float _serverSpeed;
<<<<<<< HEAD
        bool _hideIfNotInterpolation;

        UnityEngine.Transform _viewModel;

        public ConstantSpeedNetworkInterpolate Init(IGameTime gameTime, double maxDistance = _defMaxDistance, bool hideIfNotInterpolation = false, double rotationLerpSpeed = -1.0)
        {
            _gameTime = gameTime;
            _maxDistance = maxDistance;
=======

        public ConstantSpeedNetworkInterpolate Init(IGameTime gameTime, double maxDistance = _defMaxDistance, double rotationLerpSpeed = -1.0)
        {
            _gameTime = gameTime;
            _maxDistance = maxDistance;
            _maxDistanceSQ = maxDistance * maxDistance;
>>>>>>> origin/master
            Enable = true;
            _iterationCount = 0;
            _dir = JVector.Zero;
            _rotationLerpSpeed = rotationLerpSpeed;
            _canSmooth = false;
<<<<<<< HEAD
            _hideIfNotInterpolation = hideIfNotInterpolation;
=======
>>>>>>> origin/master
            return this;
        }

        public void OnServerTransform(Transform t, float serverTimestampf)
        {
<<<<<<< HEAD
            if(_go == null)
            {
                return;
            }

            _serverTimeStamp = (double)serverTimestampf;
            _canSmooth = CanSmooth(t);

            if(_canSmooth)
            {
                var serverDeltaPos = t.Position - _serverPos;
                var serverDeltaMag = serverDeltaPos.Length();
                if(serverDeltaMag > _epsilon)
                {
                    _canSmooth = CanSmooth(t);
                    if(_canSmooth)
                    {   
                        _serverSpeed = serverDeltaMag / ((float)_serverTimeStamp);
                        var positionDelta = t.Position - _go.Transform.Position;
                        if(positionDelta.LengthSquared() > _epsilon)
                        {
                            _dir = positionDelta.Normalized();
                        }
                        else
                        {
                            _dir = JVector.Zero;
                        }
                    }
                }
            }

            if(!_canSmooth)
            {
                ResetToCurrentTransform(t);
            }

            _serverPos = t.Position;
            _serverRotation = t.Rotation;
            _go.Transform.Scale = t.Scale;
            _iterationCount++;

            RefreshVisibility();
=======
            var serverDeltaPos = t.Position - _prevServerPos;
            var serverDeltaMag = serverDeltaPos.Length();
            if(serverDeltaMag > _epsilon)
            {
                _serverTimeStamp = (double)serverTimestampf;

                if(_go == null)
                {
                    _iterationCount = 0;
                    return;
                }

                _canSmooth = CanSmooth(t);
                if(_canSmooth)
                {   
                    _serverSpeed = serverDeltaMag / ((float)_serverTimeStamp);
                    var positionDelta = t.Position - _go.Transform.Position;
                    if(positionDelta.LengthSquared() > _epsilon)
                    {
                        _dir = positionDelta.Normalized();
                    }
                    else
                    {
                        _dir = JVector.Zero;
                    }
                }

                if(!_canSmooth)
                {
                    ResetToCurrentTransform(t);
                }

                _prevServerPos = t.Position;
            }
            _targetRotationPredicted = t.Rotation;
            _go.Transform.Scale = t.Scale;
            _iterationCount++;
>>>>>>> origin/master
        }

        bool CanSmooth(Transform t)
        {
            if(!Enable)
            {
                return false;
            }

            if(_iterationCount < _minIterationCount)
            {
                return false;
            }

            if((t.Position - _go.Transform.Position).ZeroYValue().LengthSquared() > _maxDistanceSQ)
            {
                return false;
            }

<<<<<<< HEAD
            if(_serverTimeStamp <= 0f)
=======
            if(_serverTimeStamp < _epsilon)
>>>>>>> origin/master
            {
                return false;
            }

            return true;
        }

        void ResetToCurrentTransform(Transform t)
        {
<<<<<<< HEAD
            _go.Transform.Position = _serverPos = t.Position;
=======
            _go.Transform.Position = _prevServerPos = t.Position;
>>>>>>> origin/master
            _serverSpeed = 0;
        }

        public void OnAwake()
        {
<<<<<<< HEAD
            _maxDistanceSQ = _maxDistance * _maxDistance;
            var view = _go.GetBehaviour<UnityViewBehaviour>();
            _viewModel = view.View.transform.childCount > 0 ? view.View.transform.GetChild(0) : view.View.transform;
            RefreshVisibility();
=======
>>>>>>> origin/master
        }

        public void OnStart()
        {
<<<<<<< HEAD
        }

        void RefreshVisibility()
        {
            if(_hideIfNotInterpolation && _viewModel != null)
            {
                _viewModel.gameObject.SetActiveSafe(_iterationCount > 1);
            }
=======
            _iterationCount = 0;
>>>>>>> origin/master
        }

        public void OnDestroy()
        {
        }

        public void Update(float dt)
        {
            Enable &= InterpolationSettings.Enable;

            if(_iterationCount < _minIterationCount)
            {
                return;
            }
            
            if(Enable)
            {
                InterpolatePosition(dt);
            }

            InterpolateRotation(dt);
        }

        void InterpolatePosition(float dt)
        {
<<<<<<< HEAD
            var currToServerLength = (_serverPos - _go.Transform.Position).Length();
            var delta = (float)_serverSpeed * dt;
            if(delta > currToServerLength)
            {
                _go.Transform.Position = _serverPos;
=======
            var currToServerLength = (_prevServerPos - _go.Transform.Position).Length();
            var delta = (float)_serverSpeed * dt;
            if(delta > currToServerLength)
            {
                _go.Transform.Position = _prevServerPos;
>>>>>>> origin/master
                _serverSpeed = 0f;
            }
            else
            {
                _go.Transform.Position = _go.Transform.Position + _dir * delta;
            }
        }

        void InterpolateRotation(float dt)
        {
<<<<<<< HEAD
            var rotationLerpSpeed =  _rotationLerpSpeed > 0.0 ? _rotationLerpSpeed : InterpolationSettings.RotationLerpSpeed;
            JQuaternion targetRotation = JQuaternion.Identity;
            JQuaternionUtils.Slerp(ref _go.Transform.Rotation, ref _serverRotation, (float)Math.Min(1f, (dt * rotationLerpSpeed)), out targetRotation);
=======
            var rotationLerpSpeed = _rotationLerpSpeed > 0.0 ? _rotationLerpSpeed : InterpolationSettings.RotationLerpSpeed;
            JQuaternion targetRotation = JQuaternion.Identity;
            JQuaternionUtils.Slerp(ref _go.Transform.Rotation, ref _targetRotationPredicted, (float)Math.Min(1f, (dt * rotationLerpSpeed)), out targetRotation);
>>>>>>> origin/master
            _go.Transform.Rotation = targetRotation;
        }

        public object Clone()
        {
<<<<<<< HEAD
            var other = _go != null ? _go.Context.Pool.Get<ConstantSpeedNetworkInterpolate>() : new ConstantSpeedNetworkInterpolate();
            other.Init(_gameTime, _maxDistance);
            other.Enable = Enable;
            other._hideIfNotInterpolation = _hideIfNotInterpolation;
            other._rotationLerpSpeed = _rotationLerpSpeed;
=======
            var other = ObjectPool.Get<ConstantSpeedNetworkInterpolate>().Init(_gameTime, _maxDistance);
            other.Enable = Enable;
>>>>>>> origin/master
            return other;
        }

        public void Dispose()
        {
<<<<<<< HEAD
            _go.Context.Pool.Return(this);
=======
            ObjectPool.Return(this);
>>>>>>> origin/master
        }

        public NetworkGameObject GameObject
        {
            set
            {
                _go = value;
<<<<<<< HEAD
                _iterationCount = 0;
=======
>>>>>>> origin/master
            }
        }
    }
}

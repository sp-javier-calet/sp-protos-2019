using System;
using System.Collections.Generic;

namespace SocialPoint.Pooling
{
    public static class ObjectPool
    {
        static Dictionary<Type, object> poolDictionary = new Dictionary<Type, object>();
        static Dictionary<int, object> idPoolDictionary = new Dictionary<int, object>();

        #region typepool
        public static T Get<T>(Func<T> fallback = null)
        {
            var objType = typeof(T);
            object pooledObjects = null;

            if(poolDictionary.TryGetValue(objType, out pooledObjects))
            {
                var pooledObjectsCasted = (Stack<T>)pooledObjects;
                if(pooledObjectsCasted.Count > 0)
                {
                    return pooledObjectsCasted.Pop();
                }
            }

            return fallback != null ? fallback() : (T)CreateInstance(objType);
        }

        public static void Return<T>(T obj)
        {
            DoReturnByType(obj);
        }

        public static void Return<T>(List<T> list)
        {
            list.Clear();
            DoReturnByType(list);
        }

        static void DoReturnByType<T>(T obj)
        {
            if(obj == null)
            {
<<<<<<< HEAD
                obj = Object.Instantiate(prefab);
            }
            SetupTransform(parent, position, rotation, obj);
            SetupParticleSystems(obj);
            if(addToSpawnedObjects)
            {
                Instance._spawnedObjects.Add(obj, prefab);
            }
            return obj;
        }

        static void SetupTransform(Transform parent, Vector3 position, Quaternion rotation, GameObject obj)
        {
            obj.transform.SetParent(parent);
            obj.transform.localPosition = position;
            obj.transform.localRotation = rotation;
        }

        static void SetupParticleSystems(GameObject obj)
        {
            ParticleSystem[] m_particleSystems = obj.GetComponentsInChildren<ParticleSystem>(true);

            for(int j = 0; j < m_particleSystems.Length; ++j)
            {
                m_particleSystems[j].Stop();
                var emission = m_particleSystems[j].emission;
                emission.enabled = false;
            }

            for(int j = 0; j < m_particleSystems.Length; ++j)
            {
                m_particleSystems[j].Play();
                var emission = m_particleSystems[j].emission;
                emission.enabled = true;
            }
            obj.SetActive(false);
            obj.SetActive(true);
        }

        static void LogWarningSpawningPrefabNotInPool(GameObject nonPooledPrefab)
        {
            if(!Instance._nonPulledPrefabs.Contains(nonPooledPrefab))
            {
                Instance._nonPulledPrefabs.Add(nonPooledPrefab);
                Log.w("ObjectPool: " + nonPooledPrefab.name);
            }
        }

        public static GameObject Spawn(GameObject prefab, Transform parent, Vector3 position)
        {
            return Spawn(prefab, parent, position, Quaternion.identity);
        }

        public static GameObject Spawn(GameObject prefab, Vector3 position, Quaternion rotation)
        {
            return Spawn(prefab, null, position, rotation);
        }

        public static GameObject Spawn(GameObject prefab, Transform parent)
        {
            return Spawn(prefab, parent, Vector3.zero, Quaternion.identity);
        }

        public static GameObject Spawn(GameObject prefab, Vector3 position)
        {
            return Spawn(prefab, null, position, Quaternion.identity);
        }

        public static GameObject Spawn(GameObject prefab)
        {
            return Spawn(prefab, null, Vector3.zero, Quaternion.identity);
        }

        public static void Recycle<T>(T obj) where T : Component
        {
            Recycle(obj.gameObject);
        }

        public static void Recycle(GameObject obj)
        {
            if(!Instance || obj == null)
            {           
                SocialPoint.Base.DebugUtils.Assert(obj != null, "ObjectPool: Trying to recycle null object");
=======
>>>>>>> origin/master
                return;
            }

            var objType = typeof(T);
            object pooledObjects = null;
            Stack<T> pooledObjectsCasted = null;

            if(!poolDictionary.TryGetValue(objType, out pooledObjects))
            {
                pooledObjectsCasted = new Stack<T>();
                poolDictionary.Add(objType, pooledObjectsCasted);
            }
            else
            {
                pooledObjectsCasted = (Stack<T>)pooledObjects;
            }

            pooledObjectsCasted.Push(obj);
        }
        #endregion typepool

        #region idpool
        public static T Get<T>(int id, Func<T> fallback = null)
        {
            var objType = typeof(T);
            object pooledObjects = null;

            if(idPoolDictionary.TryGetValue(id, out pooledObjects))
            {
                var pooledObjectsCasted = (Stack<T>)pooledObjects;
                if(pooledObjectsCasted.Count > 0)
                {
                    return pooledObjectsCasted.Pop();
                }
            }

            return fallback != null ? fallback() : (T)CreateInstance(objType);
        }

        public static void Return<T>(int id, List<T> list)
        {
            list.Clear();
            DoReturnById(id, list);
        }

        public static void Return<T>(int id, T obj)
        {
            DoReturnById(id, obj);
        }

        static void DoReturnById<T>(int id, T obj)
        {
            if(obj == null)
            {
                return;
            }

            object pooledObjects = null;
            Stack<T> pooledObjectsCasted = null;

            if(!idPoolDictionary.TryGetValue(id, out pooledObjects))
            {
                pooledObjectsCasted = new Stack<T>();
                idPoolDictionary.Add(id, pooledObjectsCasted);
            }
            else
            {
                pooledObjectsCasted = (Stack<T>)pooledObjects;
            }

            pooledObjectsCasted.Push(obj);
        }
        #endregion idpool

        static object CreateInstance(Type t)
        {
            return Activator.CreateInstance(t);
        }
    }
}